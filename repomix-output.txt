This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/element
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  element/
    Animation.tsx
    css.ts
    Element.tsx
    utils.ts

================================================================
Files
================================================================

================
File: src/element/Animation.tsx
================
// animations.ts

import { AnimationProps } from '../utils/constants';

export const fadeIn = ({
  duration = '1s',
  timingFunction = 'ease',
  ...props
}: AnimationProps) => ({
  from: { opacity: 0 },
  to: { opacity: 1 },
  duration,
  timingFunction,
  ...props,
});

export const fadeOut = ({
  duration = '1s',
  timingFunction = 'ease',
  ...props
}: AnimationProps) => ({
  from: { opacity: 1 },
  to: { opacity: 0 },
  duration,
  timingFunction,
  ...props,
});

export const slideInLeft = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateX(-100%)' },
  to: { transform: 'translateX(0)' },
  duration,
  timingFunction,
  ...props,
});

export const slideInRight = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateX(100%)' },
  to: { transform: 'translateX(0)' },
  duration,
  timingFunction,
  ...props,
});

export const slideInDown = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateY(-100%)' },
  to: { transform: 'translateY(0)' },
  duration,
  timingFunction,
  ...props,
});

export const slideInUp = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateY(100%)' },
  to: { transform: 'translateY(0)' },
  duration,
  timingFunction,
  ...props,
});

export const bounce = ({
  duration = '2s',
  timingFunction = 'ease',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateY(0)' },
  '20%': { transform: 'translateY(-30px)' },
  '40%': { transform: 'translateY(0)' },
  '60%': { transform: 'translateY(-15px)' },
  '80%': { transform: 'translateY(0)' },
  to: { transform: 'translateY(0)' },
  duration,
  timingFunction,
  iterationCount,
  ...props,
});

export const rotate = ({
  duration = '1s',
  timingFunction = 'linear',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'rotate(0deg)' },
  to: { transform: 'rotate(360deg)' },
  duration,
  timingFunction,
  iterationCount,
  ...props,
});

export const pulse = ({
  duration = '1s',
  timingFunction = 'ease-in-out',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale(1)' },
  '50%': { transform: 'scale(1.05)' },
  to: { transform: 'scale(1)' },
  duration,
  timingFunction,
  iterationCount,
  ...props,
});

export const zoomIn = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale(0)' },
  to: { transform: 'scale(1)' },
  duration,
  timingFunction,
  ...props,
});

export const zoomOut = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale(1)' },
  to: { transform: 'scale(0)' },
  duration,
  timingFunction,
  ...props,
});

export const flash = ({
  duration = '1s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { opacity: 1 },
  '50%': { opacity: 0 },
  to: { opacity: 1 },
  duration,
  iterationCount,
  ...props,
});

export const shake = ({
  duration = '0.5s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateX(0)' },
  '10%': { transform: 'translateX(-10px)' },
  '20%': { transform: 'translateX(10px)' },
  '30%': { transform: 'translateX(-10px)' },
  '40%': { transform: 'translateX(10px)' },
  '50%': { transform: 'translateX(-10px)' },
  '60%': { transform: 'translateX(10px)' },
  '70%': { transform: 'translateX(-10px)' },
  '80%': { transform: 'translateX(10px)' },
  '90%': { transform: 'translateX(-10px)' },
  to: { transform: 'translateX(0)' },
  duration,
  iterationCount,
  ...props,
});

export const swing = ({
  duration = '1s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'rotate(0deg)' },
  '20%': { transform: 'rotate(15deg)' },
  '40%': { transform: 'rotate(-10deg)' },
  '60%': { transform: 'rotate(5deg)' },
  '80%': { transform: 'rotate(-5deg)' },
  to: { transform: 'rotate(0deg)' },
  duration,
  iterationCount,
  ...props,
});

export const rubberBand = ({
  duration = '1s',
  timingFunction = 'ease-in-out',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale3d(1, 1, 1)' },
  '30%': { transform: 'scale3d(1.25, 0.75, 1)' },
  '40%': { transform: 'scale3d(0.75, 1.25, 1)' },
  '50%': { transform: 'scale3d(1.15, 0.85, 1)' },
  '65%': { transform: 'scale3d(0.95, 1.05, 1)' },
  '75%': { transform: 'scale3d(1.05, 0.95, 1)' },
  to: { transform: 'scale3d(1, 1, 1)' },
  duration,
  timingFunction,
  ...props,
});

export const wobble = ({ duration = '1s', ...props }) => ({
  from: { transform: 'translateX(0%)' },
  '15%': { transform: 'translateX(-25%) rotate(-5deg)' },
  '30%': { transform: 'translateX(20%) rotate(3deg)' },
  '45%': { transform: 'translateX(-15%) rotate(-3deg)' },
  '60%': { transform: 'translateX(10%) rotate(2deg)' },
  '75%': { transform: 'translateX(-5%) rotate(-1deg)' },
  to: { transform: 'translateX(0%)' },
  duration,
  ...props,
});

export const flip = ({ duration = '1s', ...props }) => ({
  from: {
    transform: 'perspective(400px) rotateY(0deg)',
  },
  '40%': {
    transform: 'perspective(400px) rotateY(-180deg)',
  },
  to: {
    transform: 'perspective(400px) rotateY(-360deg)',
  },
  duration,
  ...props,
});

export const heartBeat = ({
  duration = '1.3s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale(1)' },
  '14%': { transform: 'scale(1.3)' },
  '28%': { transform: 'scale(1)' },
  '42%': { transform: 'scale(1.3)' },
  '70%': { transform: 'scale(1)' },
  to: { transform: 'scale(1)' },
  duration,
  iterationCount,
  ...props,
});

export const rollIn = ({ duration = '1s', ...props }) => ({
  from: {
    opacity: 0,
    transform: 'translateX(-100%) rotate(-120deg)',
  },
  to: {
    opacity: 1,
    transform: 'translateX(0px) rotate(0deg)',
  },
  duration,
  ...props,
});

export const rollOut = ({ duration = '1s', ...props }) => ({
  from: {
    opacity: 1,
    transform: 'translateX(0px) rotate(0deg)',
  },
  to: {
    opacity: 0,
    transform: 'translateX(100%) rotate(120deg)',
  },
  duration,
  ...props,
});

export const lightSpeedIn = ({
  duration = '1s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'translateX(100%) skewX(-30deg)',
    opacity: 0,
  },
  '60%': {
    transform: 'skewX(20deg)',
    opacity: 1,
  },
  '80%': {
    transform: 'skewX(-5deg)',
  },
  to: {
    transform: 'translateX(0)',
    opacity: 1,
  },
  duration,
  timingFunction,
  ...props,
});

export const lightSpeedOut = ({
  duration = '1s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 1,
  },
  '20%': {
    opacity: 1,
    transform: 'translateX(-20%) skewX(20deg)',
  },
  to: {
    opacity: 0,
    transform: 'translateX(-100%) skewX(30deg)',
  },
  duration,
  timingFunction,
  ...props,
});

export const hinge = ({
  duration = '2s',
  timingFunction = 'ease-in-out',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'rotate(0deg)',
    transformOrigin: 'top left',
    opacity: 1,
  },
  '20%': {
    transform: 'rotate(80deg)',
    opacity: 1,
  },
  '40%': {
    transform: 'rotate(60deg)',
    opacity: 1,
  },
  '60%': {
    transform: 'rotate(80deg)',
    opacity: 1,
  },
  '80%': {
    transform: 'rotate(60deg)',
    opacity: 1,
  },
  to: {
    transform: 'translateY(700px)',
    opacity: 0,
  },
  duration,
  timingFunction,
  ...props,
});

export const jackInTheBox = ({
  duration = '1s',
  timingFunction = 'ease',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 0,
    transform: 'scale(0.1) rotate(30deg)',
    transformOrigin: 'center bottom',
  },
  '50%': {
    transform: 'rotate(-10deg)',
  },
  '70%': {
    transform: 'rotate(3deg)',
  },
  to: {
    opacity: 1,
    transform: 'scale(1) rotate(0deg)',
  },
  duration,
  timingFunction,
  ...props,
});

export const flipInX = ({
  duration = '1s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'perspective(400px) rotateX(90deg)',
    opacity: 0,
  },
  '40%': {
    transform: 'perspective(400px) rotateX(-10deg)',
    opacity: 1,
  },
  to: {
    transform: 'perspective(400px) rotateX(0deg)',
  },
  duration,
  timingFunction,
  ...props,
});

export const flipInY = ({
  duration = '1s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'perspective(400px) rotateY(90deg)',
    opacity: 0,
  },
  '40%': {
    transform: 'perspective(400px) rotateY(-10deg)',
    opacity: 1,
  },
  to: {
    transform: 'perspective(400px) rotateY(0deg)',
  },
  duration,
  timingFunction,
  ...props,
});

export const headShake = ({
  duration = '1s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'translateX(0)',
  },
  '6.5%': {
    transform: 'translateX(-6px) rotateY(-9deg)',
  },
  '18.5%': {
    transform: 'translateX(5px) rotateY(7deg)',
  },
  '31.5%': {
    transform: 'translateX(-3px) rotateY(-5deg)',
  },
  '43.5%': {
    transform: 'translateX(2px) rotateY(3deg)',
  },
  '50%': {
    transform: 'translateX(0)',
  },
  duration,
  iterationCount,
  ...props,
});

export const tada = ({
  duration = '1s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale3d(1, 1, 1)', opacity: 1 },
  '10%, 20%': {
    transform: 'scale3d(0.9, 0.9, 0.9) rotate(-3deg)',
  },
  '30%, 50%, 70%, 90%': {
    transform: 'scale3d(1.1, 1.1, 1.1) rotate(3deg)',
  },
  '40%, 60%, 80%': {
    transform: 'scale3d(1.1, 1.1, 1.1) rotate(-3deg)',
  },
  to: { transform: 'scale3d(1, 1, 1)', opacity: 1 },
  duration,
  iterationCount,
  ...props,
});

export const jello = ({
  duration = '1s',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'none' },
  '11.1%': { transform: 'skewX(-12.5deg) skewY(-12.5deg)' },
  '22.2%': { transform: 'skewX(6.25deg) skewY(6.25deg)' },
  '33.3%': { transform: 'skewX(-3.125deg) skewY(-3.125deg)' },
  '44.4%': { transform: 'skewX(1.5625deg) skewY(1.5625deg)' },
  '55.5%': { transform: 'skewX(-0.78125deg) skewY(-0.78125deg)' },
  '66.6%': { transform: 'skewX(0.390625deg) skewY(0.390625deg)' },
  '77.7%': { transform: 'skewX(-0.1953125deg) skewY(-0.1953125deg)' },
  '88.8%': { transform: 'skewX(0.09765625deg) skewY(0.09765625deg)' },
  to: { transform: 'none' },
  duration,
  iterationCount,
  ...props,
});

export const fadeInDown = ({
  duration = '1s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 0,
    transform: 'translateY(-100%)',
  },
  to: {
    opacity: 1,
    transform: 'translateY(0)',
  },
  duration,
  timingFunction,
  ...props,
});

export const fadeInUp = ({
  duration = '1s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 0,
    transform: 'translateY(100%)',
  },
  to: {
    opacity: 1,
    transform: 'translateY(0)',
  },
  duration,
  timingFunction,
  ...props,
});

export const bounceIn = ({
  duration = '0.75s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 0,
    transform: 'scale(0.3)',
  },
  '50%': {
    opacity: 1,
    transform: 'scale(1.05)',
  },
  '70%': {
    transform: 'scale(0.9)',
  },
  to: {
    transform: 'scale(1)',
  },
  duration,
  timingFunction,
  ...props,
});

export const bounceOut = ({
  duration = '0.75s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'scale(1)',
  },
  '20%': {
    transform: 'scale(0.9)',
  },
  '50%, 55%': {
    opacity: 1,
    transform: 'scale(1.1)',
  },
  to: {
    opacity: 0,
    transform: 'scale(0.3)',
  },
  duration,
  timingFunction,
  ...props,
});

export const slideOutLeft = ({
  duration = '0.5s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'translateX(0)',
  },
  to: {
    transform: 'translateX(-100%)',
  },
  duration,
  timingFunction,
  ...props,
});

export const slideOutRight = ({
  duration = '0.5s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    transform: 'translateX(0)',
  },
  to: {
    transform: 'translateX(100%)',
  },
  duration,
  timingFunction,
  ...props,
});

export const zoomInDown = ({
  duration = '1s',
  timingFunction = 'ease-out',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 0,
    transform: 'scale(0.1) translateY(-1000px)',
  },
  '60%': {
    opacity: 1,
    transform: 'scale(0.475) translateY(60px)',
  },
  to: {
    transform: 'scale(1) translateY(0)',
  },
  duration,
  timingFunction,
  ...props,
});

export const zoomOutUp = ({
  duration = '1s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 1,
    transform: 'scale(1) translateY(0)',
  },
  '40%': {
    opacity: 1,
    transform: 'scale(0.475) translateY(-60px)',
  },
  to: {
    opacity: 0,
    transform: 'scale(0.1) translateY(-1000px)',
  },
  duration,
  timingFunction,
  ...props,
});

export const backInDown = ({
  duration = '1s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 0.7,
    transform: 'translateY(-2000px) scaleY(2.5) scaleX(0.2)',
  },
  to: {
    opacity: 1,
    transform: 'translateY(0) scaleY(1) scaleX(1)',
  },
  duration,
  timingFunction,
  ...props,
});

export const backOutUp = ({
  duration = '1s',
  timingFunction = 'ease-in',
  ...props
}: AnimationProps) => ({
  from: {
    opacity: 1,
    transform: 'translateY(0)',
  },
  '80%': {
    opacity: 0.7,
    transform: 'translateY(-20px)',
  },
  to: {
    opacity: 0,
    transform: 'translateY(-2000px)',
  },
  duration,
  timingFunction,
  ...props,
});

export const shimmer = ({
  duration = '2s',
  timingFunction = 'linear',
  iterationCount = 'infinite',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateX(-100%)' },
  '50%': { transform: 'translateX(100%)' },
  to: { transform: 'translateX(100%)' },
  duration,
  timingFunction,
  iterationCount,
  ...props,
});

export const progress = ({
  duration = '2s',
  timingFunction = 'linear',
  direction = 'forwards',
  from = { width: '0%' },
  to = { width: '100%' },
  ...props
}: AnimationProps) => ({
  from,
  to,
  duration,
  timingFunction,
  direction,
  ...props,
});

export const typewriter = ({
  duration = '10s',
  steps = 10,
  iterationCount = 1,
  width = 0,
  ...props
}: AnimationProps) => ({
  from: { width: '0px' },
  to: { width: `${width}px` },
  timingFunction: `steps(${steps})`,
  duration,
  iterationCount,
  ...props,
});

export const blinkCursor = ({
  duration = '0.75s',
  timingFunction = 'step-end',
  iterationCount = 'infinite',
  color = 'black',
  ...props
}: AnimationProps) => ({
  from: { color: color },
  to: { color: color },
  '0%': { color: color },
  '50%': { color: 'transparent' },
  '100%': { color: color },
  duration,
  timingFunction,
  iterationCount,
  ...props,
});

export const fadeInScroll = ({
  duration = '0.5s',
  timingFunction = 'ease',
  timeline = 'scroll()',
  range = 'cover',
  ...props
}: AnimationProps) => ({
  from: { opacity: 0 },
  to: { opacity: 1 },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

export const slideInLeftScroll = ({
  duration = '0.5s',
  timingFunction = 'ease-out',
  timeline = 'scroll()',
  range = 'cover',
  ...props
}: AnimationProps) => ({
  from: { transform: 'translateX(-200%)' },
  to: { transform: 'translateX(0)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

export const scaleDownScroll = ({
  duration = '0.8s',
  timingFunction = 'ease',
  timeline = 'scroll()',
  range = 'cover',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale(3)' },
  to: { transform: 'scale(1)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// Text fill reveal on scroll driven by a custom property (--fill)
// Requires @property --fill defined in CSS
export const fillTextScroll = ({
  duration = '1s',
  timingFunction = 'linear',
  timeline = '--section',
  range = 'entry 100% cover 50%, cover 50% exit 0%',
  ...props
}: AnimationProps) => ({
  from: {
    '--fill': 0,
    color: 'transparent',
    backgroundPositionX:
      'calc(var(--underline-block-width) * -1), calc(var(--underline-block-width) * -1), 0',
  },
  '50%': { '--fill': 0.5 },
  to: {
    '--fill': 1,
    backgroundPositionX: '0, 0, 0',
    color: 'var(--finish-fill)',
  },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// Collapsing floating call-to-action on scroll
// This animates the width from an expanded value to a collapsed width.
export const ctaCollapseScroll = ({
  duration = '1s',
  timingFunction = 'linear',
  timeline = 'scroll()',
  range = '0 400px',
  ...props
}: AnimationProps) => ({
  from: { width: 'calc(48px + 120px)' },
  to: { width: '48px' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// Hand wave animation on scroll with a defined view range
export const handWaveScroll = ({
  duration = '2s',
  timingFunction = 'linear',
  timeline = 'scroll()',
  range = '10vh 60vh',
  ...props
}: AnimationProps) => ({
  from: { transform: 'rotate(0deg)' },
  '50%': { transform: 'rotate(20deg)' },
  to: { transform: 'rotate(0deg)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// Fade out and blur text on scroll exit
export const fadeBlurScroll = ({
  duration = '1s',
  timingFunction = 'linear',
  timeline = 'view()',
  range = 'cover 40% cover 85%',
  ...props
}: AnimationProps) => ({
  to: { opacity: 0, filter: 'blur(2rem)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// Unclip animation using clip-path on scroll
export const unclipScroll = ({
  duration = '1s',
  timingFunction = 'linear',
  timeline = '--article',
  range = 'entry',
  ...props
}: AnimationProps) => ({
  to: { clipPath: 'ellipse(220% 200% at 50% 175%)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// Scale down image (or content) on scroll using article timeline
export const scaleDownArticleScroll = ({
  duration = '1s',
  timingFunction = 'linear',
  timeline = '--article',
  range = 'entry',
  ...props
}: AnimationProps) => ({
  '0%': { transform: 'scale(5)' },
  to: { transform: 'scale(1)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

// List item scaling animation on scroll driven by an inline view-timeline (--i)
export const listItemScaleScroll = ({
  duration = '0.5s',
  timingFunction = 'ease',
  timeline = '--i',
  range = 'cover 40% cover 60%',
  ...props
}: AnimationProps) => ({
  from: { transform: 'scale(0.8)' },
  '50%': { transform: 'scale(1)' },
  duration,
  timingFunction,
  timeline,
  range,
  ...props,
});

================
File: src/element/utils.ts
================
/* eslint-disable @typescript-eslint/no-unused-vars */
// animationHelpers.ts
import { styleObjectToCss } from '../utils/style';

let keyframesCounter = 0;
const keyframesCache = new Map<string, string>();

export const generateKeyframes = (
  animation: any
): { keyframesName: string; keyframes: string } => {
  // Exclure les propriétés qui ne font pas partie des keyframes
  const {
    duration,
    timingFunction,
    delay,
    iterationCount,
    direction,
    fillMode,
    playState,
    timeline,
    range,
    ...keyframesDef
  } = animation;

  // Générer une clé pour le cache basée sur les keyframes
  const animationConfigString = JSON.stringify(keyframesDef);

  if (keyframesCache.has(animationConfigString)) {
    const keyframesName = keyframesCache.get(animationConfigString)!;
    return { keyframesName, keyframes: '' }; // Les keyframes existent déjà
  }

  const keyframesName = `animation-${keyframesCounter++}`;
  keyframesCache.set(animationConfigString, keyframesName);

  const keyframesContent: string[] = [];

  // Trier les clés pour assurer un ordre cohérent
  const keyframeKeys = Object.keys(keyframesDef).sort((a, b) => {
    const getPercentage = (key: string): number => {
      if (key === 'from') return 0;
      if (key === 'to' || key === 'enter') return 100;
      return parseInt(key.replace('%', ''), 10);
    };
    return getPercentage(a) - getPercentage(b);
  });

  keyframeKeys.forEach((key) => {
    const cssKey = key === 'enter' ? 'to' : key; // Remplacer 'enter' par 'to'
    const styles = keyframesDef[key];
    keyframesContent.push(`${cssKey} { ${styleObjectToCss(styles)} }`);
  });

  const keyframes = `
    @keyframes ${keyframesName} {
      ${keyframesContent.join('\n')}
    }
  `;

  return { keyframesName, keyframes };
};

================
File: src/element/Element.tsx
================
import React, { CSSProperties, useMemo, forwardRef } from 'react';
import { Colors, Theme, useTheme } from '../providers/Theme';
import { useResponsiveContext } from '../providers/Responsive';

import { isStyleProp } from '../utils/style';
import { AnimationProps, excludedKeys, includeKeys } from '../utils/constants';
import { extractUtilityClasses } from './css';
import { Shadow } from '../utils/shadow';
import { useAnalytics } from '../providers/Analytics';
import { ViewStyleProps } from '../types/style';

export interface ElementProps
  extends CssProps,
    Omit<ViewStyleProps, 'children' | 'style' | 'pointerEvents' | 'onClick'> {
  [key: string]: any;
  // Event handling props
  on?: Record<string, CssProps>;
  media?: Record<string, CssProps>;
  only?: string[];
  css?: CSSProperties | any;
  onPress?: any;
  onClick?: any;
  className?: string;
  themeMode?: 'light' | 'dark';
  as?: keyof JSX.IntrinsicElements;
  style?: CSSProperties;
  widthHeight?: number | string;
  children?: React.ReactNode;
  colors?: Colors;
  theme?: Theme;

  // Underscore-prefixed event props (alternative to using the 'on' prop)
  _hover?: CssProps | string;
  _active?: CssProps | string;
  _focus?: CssProps | string;
  _visited?: CssProps | string;
  _disabled?: CssProps | string;
  _enabled?: CssProps | string;
  _checked?: CssProps | string;
  _unchecked?: CssProps | string;
  _invalid?: CssProps | string;
  _valid?: CssProps | string;
  _required?: CssProps | string;
  _optional?: CssProps | string;
  _selected?: CssProps | string;
  _target?: CssProps | string;
  _firstChild?: CssProps | string;
  _lastChild?: CssProps | string;
  _onlyChild?: CssProps | string;
  _firstOfType?: CssProps | string;
  _lastOfType?: CssProps | string;
  _empty?: CssProps | string;
  _focusVisible?: CssProps | string;
  _focusWithin?: CssProps | string;
  _placeholder?: CssProps | string;
}

export interface CssProps extends CSSProperties {
  paddingHorizontal?: number | string;
  marginHorizontal?: number | string;
  paddingVertical?: number | string;
  marginVertical?: number | string;
  animate?: AnimationProps[] | AnimationProps;
  shadow?: boolean | number | Shadow;
}

export const Element = React.memo(
  forwardRef<HTMLElement, ElementProps>(
    ({ as = 'div', ...props }: ElementProps, ref) => {
      if ((props.onClick || props.onPress) && props.cursor == undefined) {
        props.cursor = 'pointer';
      }

      const { onPress, ...rest } = props;
      const { getColor, theme } = useTheme();
      const { trackEvent } = useAnalytics();
      const { mediaQueries, devices } = useResponsiveContext();

      const utilityClasses = useMemo(
        () =>
          extractUtilityClasses(
            rest,
            (color: string) => {
              return getColor(color, {
                colors: props.colors,
                theme: props.theme,
                themeMode: props.themeMode,
              });
            },
            mediaQueries,
            devices
          ),
        [rest, mediaQueries, devices, theme]
      );

      const newProps: any = { ref };
      if (onPress) {
        newProps.onClick = onPress;
      }

      if (utilityClasses.length > 0) {
        newProps.className = utilityClasses.join(' ');
      }

      if (trackEvent && props.onClick) {
        let componentName: string;
        if (typeof as === 'string') {
          componentName = as;
        } else {
          componentName =
            (as as React.ComponentType<any>).displayName ||
            (as as React.ComponentType<any>).name ||
            'div';
        }
        let text: string | undefined;
        if (typeof props.children === 'string') {
          text = props.children.slice(0, 100);
        }
        newProps.onClick = (event: any) => {
          trackEvent({
            type: 'click',
            target: componentName !== 'div' ? componentName : undefined,
            text,
          });
          if (props.onClick) {
            props.onClick(event);
          }
        };
      }

      const { style, children, ...otherProps } = rest;
      Object.keys(otherProps).forEach((key) => {
        if (
          (!excludedKeys.has(key) && !isStyleProp(key)) ||
          includeKeys.has(key)
        ) {
          newProps[key] = (otherProps as any)[key];
        }
      });

      if (style) {
        newProps.style = style;
      }

      const Component = as;
      return <Component {...newProps}>{children}</Component>;
    }
  )
);

================
File: src/element/css.ts
================
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable prefer-const */
import { Shadows } from '../utils/shadow';
import Color from 'color-convert';
import { generateKeyframes } from './utils';
import { isStyleProp, StyleProps } from '../utils/style';
import { ElementProps } from './Element';
import { numericCssProperties } from '../utils/cssProperties';

type StyleContext = 'base' | 'pseudo' | 'media' | 'modifier';

// Implement a simple LRU cache for classCache
class LRUCache<K, V> {
  private cache: Map<K, V>;
  private maxSize: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }

  get(key: K): V | undefined {
    const item = this.cache.get(key);
    if (item) {
      // Move to the end to mark as recently used
      this.cache.delete(key);
      this.cache.set(key, item);
      return item;
    }
    return undefined;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      // If already in cache, just move to the end
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove the least recently used (first item in the map)
      const firstKey = this.cache.keys().next().value;
      if (firstKey) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }

  delete(key: K): void {
    this.cache.delete(key);
  }

  get size(): number {
    return this.cache.size;
  }

  keys(): IterableIterator<K> {
    return this.cache.keys();
  }

  values(): IterableIterator<V> {
    return this.cache.values();
  }

  has(key: K): boolean {
    return this.cache.has(key);
  }
}

// Store raw CSS classes
const rawCssCache = new Map<string, string>();

/**
 * Maps a React event to a CSS pseudo-class.
 */
const EVENT_TO_PSEUDO: Record<string, string> = {
  // Basic interaction states
  hover: 'hover',
  active: 'active',
  focus: 'focus',
  visited: 'visited',
  // Form states
  disabled: 'disabled',
  enabled: 'enabled',
  checked: 'checked',
  unchecked: 'not(:checked)',
  invalid: 'invalid',
  valid: 'valid',
  required: 'required',
  optional: 'optional',
  // Selection states
  selected: 'selected',
  // Target states
  target: 'target',
  // Child states
  firstChild: 'first-child',
  lastChild: 'last-child',
  onlyChild: 'only-child',
  firstOfType: 'first-of-type',
  lastOfType: 'last-of-type',
  // Other states
  empty: 'empty',
  // Focus states
  focusVisible: 'focus-visible',
  focusWithin: 'focus-within',
  // Placeholder
  placeholder: 'placeholder-shown',
};

/**
 * Utility functions for animation handling
 */
const AnimationUtils = {
  parseDuration(duration: string): number {
    const match = duration.match(/^([\d.]+)(ms|s)$/);
    if (!match) return 0;
    const value = parseFloat(match[1]);
    const unit = match[2];
    return unit === 's' ? value * 1000 : value;
  },

  formatDuration(ms: number): string {
    if (ms >= 1000 && ms % 1000 === 0) {
      return `${ms / 1000}s`;
    }
    return `${ms}ms`;
  },

  processAnimations(animations: any[]) {
    const result = {
      names: [] as string[],
      durations: [] as string[],
      timingFunctions: [] as string[],
      delays: [] as string[],
      iterationCounts: [] as string[],
      directions: [] as string[],
      fillModes: [] as string[],
      playStates: [] as string[],
      timelines: [] as string[],
      ranges: [] as string[],
    };

    let cumulativeTime = 0;

    animations.forEach((animation) => {
      const { keyframesName, keyframes } = generateKeyframes(animation);
      if (keyframes && typeof document !== 'undefined') {
        utilityClassManager.injectRule(keyframes);
      }

      result.names.push(keyframesName);

      const durationMs = this.parseDuration(animation.duration || '0s');
      const delayMs = this.parseDuration(animation.delay || '0s');
      const totalDelayMs = cumulativeTime + delayMs;

      cumulativeTime = totalDelayMs + durationMs;

      result.durations.push(this.formatDuration(durationMs));
      result.timingFunctions.push(animation.timingFunction || 'ease');
      result.delays.push(this.formatDuration(totalDelayMs));
      result.iterationCounts.push(
        animation.iterationCount !== undefined
          ? `${animation.iterationCount}`
          : '1'
      );
      result.directions.push(animation.direction || 'normal');
      result.fillModes.push(animation.fillMode || 'none');
      result.playStates.push(animation.playState || 'running');
      result.timelines.push(animation.timeline || '');
      result.ranges.push(animation.range || '');
    });

    return {
      animationName: result.names.join(', '),
      animationDuration: result.durations.join(', '),
      animationTimingFunction: result.timingFunctions.join(', '),
      animationDelay: result.delays.join(', '),
      animationIterationCount: result.iterationCounts.join(', '),
      animationDirection: result.directions.join(', '),
      animationFillMode: result.fillModes.join(', '),
      animationPlayState: result.playStates.join(', '),
      ...(result.timelines.some((t) => t) && {
        animationTimeline: result.timelines.join(', '),
      }),
      ...(result.ranges.some((r) => r) && {
        animationRange: result.ranges.join(', '),
      }),
    };
  },
};

/**
 * Utility functions for value processing
 */
const ValueUtils = {
  formatValue(
    value: any,
    property: string,
    getColor: (color: string) => string
  ): any {
    let processedValue = value;

    // If the property is a color, convert it
    if (property.toLowerCase().includes('color')) {
      processedValue = getColor(value);
    }

    // Handle border properties that might contain color values
    if (typeof value === 'string' && value.length > 3) {
      // Parse border property to extract color
      const parts = value.split(' ');
      // Check each part to see if it starts with 'color.' or 'theme.'
      const processedParts = parts.map((part) => {
        if (part.startsWith('color.') || part.startsWith('theme.')) {
          // Process the color part through getColor
          return getColor(part);
        }
        return part;
      });
      // Reconstruct the value with processed parts
      processedValue = processedParts.join(' ');
    }

    // Handle numeric values
    if (typeof processedValue === 'number') {
      if (numericCssProperties.has(property)) {
        processedValue = `${processedValue}px`;
      }
    }

    return processedValue;
  },

  normalizeCssValue(value: any): string {
    return value
      .toString()
      .replace(/\./g, 'p')
      .replace(/\s+/g, '-')
      .replace(/[^a-zA-Z0-9\-]/g, '')
      .replace(/%/g, 'pct')
      .replace(/vw/g, 'vw')
      .replace(/vh/g, 'vh')
      .replace(/em/g, 'em')
      .replace(/rem/g, 'rem');
  },

  generateUniqueClassName(css: string): string {
    if (rawCssCache.has(css)) {
      return rawCssCache.get(css)!;
    }

    const shortName = Math.random().toString(36).substring(7);
    const newClassName = `raw-css-${shortName}`;

    rawCssCache.set(css, newClassName);
    return newClassName;
  },
};

class UtilityClassManager {
  private styleSheets: Map<Document, Record<StyleContext, CSSStyleSheet>> =
    new Map();
  private classCache: LRUCache<
    string,
    {
      className: string;
      rules: Array<{
        rule: string;
        context: StyleContext;
      }>;
    }
  >;
  private propertyShorthand: Record<string, string>;
  private mainDocument: Document | null = null;

  constructor(
    propertyShorthand: Record<string, string>,
    maxCacheSize: number = 10000
  ) {
    this.propertyShorthand = propertyShorthand;
    this.classCache = new LRUCache(maxCacheSize);

    if (typeof document !== 'undefined') {
      this.mainDocument = document;
      this.initStyleSheets(document);
    }
  }

  private initStyleSheets(targetDocument: Document) {
    if (!this.styleSheets.has(targetDocument)) {
      const sheetMap: Record<StyleContext, CSSStyleSheet> = {} as any;

      // Initialize all style sheets at once
      const contextIds: Record<StyleContext, string> = {
        base: 'utility-classes-base',
        pseudo: 'utility-classes-pseudo',
        media: 'utility-classes-media',
        modifier: 'utility-classes-modifier',
      };

      for (const [context, id] of Object.entries(contextIds)) {
        let styleTag = targetDocument.getElementById(id) as HTMLStyleElement;

        if (!styleTag) {
          styleTag = targetDocument.createElement('style');
          styleTag.id = id;
          targetDocument.head.appendChild(styleTag);
        }

        sheetMap[context as StyleContext] = styleTag.sheet as CSSStyleSheet;
      }

      this.styleSheets.set(targetDocument, sheetMap);
    }
  }

  private getDocumentRules(targetDocument: Document): Array<{
    cssText: string;
    context: StyleContext;
  }> {
    const rules: Array<{ cssText: string; context: StyleContext }> = [];
    const styleSheetsMap = this.styleSheets.get(targetDocument);

    if (!styleSheetsMap) return rules;

    // Get rules from all contexts
    for (const [context, sheet] of Object.entries(styleSheetsMap)) {
      Array.from(sheet.cssRules).forEach((rule) => {
        rules.push({ cssText: rule.cssText, context: context as StyleContext });
      });
    }

    return rules;
  }

  public addDocument(targetDocument: Document) {
    if (targetDocument === this.mainDocument) return;

    this.initStyleSheets(targetDocument);
    this.clearStylesFromDocument(targetDocument);

    // Copy rules from main document
    if (this.mainDocument) {
      const mainRules = this.getDocumentRules(this.mainDocument);
      mainRules.forEach(({ cssText, context }) => {
        this.injectRuleToDocument(cssText, context, targetDocument);
      });
    }
  }

  private clearStylesFromDocument(targetDocument: Document) {
    const styleSheetsMap = this.styleSheets.get(targetDocument);
    if (!styleSheetsMap) return;

    for (const sheet of Object.values(styleSheetsMap)) {
      this.clearStyleSheet(sheet);
    }
  }

  private escapeClassName(className: string): string {
    return className.replace(/:/g, '\\:');
  }

  public injectRule(cssRule: string, context: StyleContext = 'base') {
    // Inject to main document
    if (this.mainDocument) {
      this.injectRuleToDocument(cssRule, context, this.mainDocument);
    }

    // Inject to all other documents
    for (const document of this.getAllRegisteredDocuments()) {
      if (document !== this.mainDocument) {
        this.injectRuleToDocument(cssRule, context, document);
      }
    }
  }

  private getAllRegisteredDocuments(): Document[] {
    return Array.from(this.styleSheets.keys());
  }

  private addToCache(
    key: string,
    className: string,
    rules: Array<{ rule: string; context: StyleContext }>
  ) {
    this.classCache.set(key, { className, rules });
  }

  public getClassNames(
    property: string,
    value: any,
    context: StyleContext = 'base',
    modifier: string = '',
    getColor: (color: string) => string,
    mediaQueries: string[] = []
  ): string[] {
    // Format value
    let processedValue = ValueUtils.formatValue(value, property, getColor);

    let formattedValue = processedValue.toString().split(' ').join('-');
    let key = `${property}:${formattedValue}`;
    if (modifier && context !== 'base') {
      key = `${property}:${formattedValue}|${context}:${modifier}`;
    }

    // Check cache
    const cached = this.classCache.get(key);
    if (cached) {
      return [cached.className];
    }

    // Get property shorthand
    let shorthand =
      this.propertyShorthand[property] ||
      property.replace(/([A-Z])/g, '-$1').toLowerCase();

    // Normalize the value for class name generation
    let normalizedValue = ValueUtils.normalizeCssValue(formattedValue);

    // Generate class name
    let baseClassName = `${shorthand}-${normalizedValue}`;
    let classNames: string[] = [baseClassName];
    let rules: Array<{ rule: string; context: StyleContext }> = [];

    // Format CSS property name
    const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
    let valueForCss = processedValue;

    // Handle numeric values for CSS
    if (
      typeof valueForCss === 'number' &&
      numericCssProperties.has(cssProperty)
    ) {
      valueForCss = `${valueForCss}px`;
    }

    // Generate CSS rules based on context
    if (context === 'pseudo' && modifier) {
      const pseudoClassName = `${baseClassName}--${modifier}`;
      classNames = [pseudoClassName];
      const escapedClassName = this.escapeClassName(pseudoClassName);
      rules.push({
        rule: `.${escapedClassName}:${modifier} { ${cssProperty}: ${valueForCss}; }`,
        context: 'pseudo',
      });
    } else if (context === 'media' && modifier) {
      const mediaClassName = `${modifier}--${baseClassName}`;
      classNames = [mediaClassName];
      const escapedClassName = this.escapeClassName(mediaClassName);

      mediaQueries.forEach((mq) => {
        rules.push({
          rule: `@media ${mq} { .${escapedClassName} { ${cssProperty}: ${valueForCss}; } }`,
          context: 'media',
        });
      });
    } else {
      const escapedClassName = this.escapeClassName(baseClassName);
      rules.push({
        rule: `.${escapedClassName} { ${cssProperty}: ${valueForCss}; }`,
        context: 'base',
      });
    }

    // Inject all rules
    rules.forEach(({ rule, context }) => {
      this.injectRule(rule, context);
    });

    // Cache the generated rules
    this.addToCache(key, classNames[0], rules);

    return classNames;
  }

  public removeDocument(targetDocument: Document) {
    if (targetDocument === this.mainDocument) return;
    this.styleSheets.delete(targetDocument);
  }

  public clearCache() {
    this.classCache.clear();
  }

  private clearStyleSheet(styleSheet: CSSStyleSheet) {
    while (styleSheet.cssRules.length > 0) {
      styleSheet.deleteRule(0);
    }
  }

  public regenerateStyles(targetDocument: Document) {
    if (targetDocument === this.mainDocument) {
      // For main document, regenerate from cache
      this.clearStylesFromDocument(targetDocument);
      const values = Array.from(this.classCache.values());
      for (const { rules } of values) {
        rules.forEach(
          ({ rule, context }: { rule: string; context: StyleContext }) => {
            this.injectRuleToDocument(rule, context, targetDocument);
          }
        );
      }
    } else {
      // For other documents, copy from main document
      this.addDocument(targetDocument);
    }
  }

  public regenerateAllStyles() {
    for (const document of this.getAllRegisteredDocuments()) {
      this.regenerateStyles(document);
    }
  }

  private injectRuleToDocument(
    cssRule: string,
    context: StyleContext,
    targetDocument: Document
  ) {
    const styleSheetsMap = this.styleSheets.get(targetDocument);
    if (!styleSheetsMap) return;

    const styleSheet = styleSheetsMap[context];

    if (styleSheet) {
      try {
        styleSheet.insertRule(cssRule, styleSheet.cssRules.length);
      } catch (e) {
        console.error(`Error inserting CSS rule to document: "${cssRule}"`, e);
      }
    }
  }

  // Debug helper
  public printStyles(targetDocument: Document) {
    console.group('Current styles for document:');

    const styleSheetsMap = this.styleSheets.get(targetDocument);
    if (!styleSheetsMap) {
      console.log('No styles found for this document');
      console.groupEnd();
      return;
    }

    for (const [context, sheet] of Object.entries(styleSheetsMap)) {
      console.group(`${context} styles:`);
      Array.from(sheet.cssRules).forEach((rule, i) => {
        console.log(`${i}: ${rule.cssText}`);
      });
      console.groupEnd();
    }

    console.groupEnd();
  }
}

/**
 * Generates shorthand abbreviations for CSS properties.
 */
function generatePropertyShorthand(
  styledProps: string[]
): Record<string, string> {
  const propertyShorthand: Record<string, string> = {};
  const usedAbbreviations = new Set<string>();

  function generateAbbreviation(prop: string): string {
    const first = prop[0].toLowerCase();
    const last = prop[prop.length - 1].toLowerCase();
    const middle = prop.slice(1, -1).replace(/[a-z]/g, '').toLowerCase();
    let abbr = first + middle + last;
    if (abbr.length < 2) {
      abbr = prop.slice(0, 2).toLowerCase();
    }
    let i = 0;
    let uniqueAbbr = abbr;
    while (usedAbbreviations.has(uniqueAbbr)) {
      i++;
      uniqueAbbr = abbr + prop.slice(-i).toLowerCase();
    }
    usedAbbreviations.add(uniqueAbbr);
    return uniqueAbbr;
  }

  for (const prop of styledProps) {
    propertyShorthand[prop] = generateAbbreviation(prop);
  }
  return propertyShorthand;
}

const propertyShorthand = generatePropertyShorthand(StyleProps);
export const utilityClassManager = new UtilityClassManager(
  propertyShorthand,
  10000
);

/**
 * Process styles for various contexts (base, pseudo, media)
 */
function processStyles(
  styles: Record<string, any>,
  context: StyleContext = 'base',
  modifier: string = '',
  getColor: (color: string) => string,
  mediaQueries: Record<string, string> = {},
  devices: Record<string, string[]> = {}
): string[] {
  const classes: string[] = [];

  Object.keys(styles).forEach((property) => {
    const value = styles[property];
    let mediaQueriesForClass: string[] = [];

    if (context === 'media') {
      if (mediaQueries[modifier]) {
        mediaQueriesForClass = [mediaQueries[modifier]];
      } else if (devices[modifier]) {
        mediaQueriesForClass = devices[modifier]
          .map((mq) => mediaQueries[mq])
          .filter((mq) => mq);
      }
    }

    if (value !== undefined && value !== '') {
      const classNames = utilityClassManager.getClassNames(
        property,
        value,
        context,
        modifier,
        getColor,
        mediaQueriesForClass
      );
      classes.push(...classNames);
    }
  });

  return classes;
}

/**
 * Process event-based styles (hover, focus, etc.)
 */
function processEventStyles(
  eventName: string,
  eventStyles: any,
  getColor: (color: string) => string
): string[] {
  const classes: string[] = [];
  const {
    animate = undefined,
    shadow = undefined,
    ...otherEventStyles
  } = typeof eventStyles === 'object' && eventStyles !== null
    ? eventStyles
    : { color: eventStyles };

  // Process animations if present
  if (animate) {
    const animations = Array.isArray(animate) ? animate : [animate];
    const animationStyles = AnimationUtils.processAnimations(animations);
    Object.assign(otherEventStyles, animationStyles);
  }

  // Process shadow if present
  if (shadow !== undefined) {
    let shadowValue: number;

    if (typeof shadow === 'number' && Shadows[shadow] !== undefined) {
      shadowValue = shadow;
    } else if (typeof shadow === 'boolean') {
      shadowValue = shadow ? 2 : 0;
    } else {
      shadowValue = 2;
    }

    if (Shadows[shadowValue]) {
      const { shadowColor, shadowOpacity, shadowOffset, shadowRadius } =
        Shadows[shadowValue];
      const rgb = Color.hex.rgb(shadowColor);
      const rgbaColor = `rgba(${rgb.join(',')}, ${shadowOpacity})`;
      otherEventStyles.boxShadow = `${shadowOffset.height}px ${shadowOffset.width}px ${shadowRadius}px ${rgbaColor}`;
    }
  }

  // Apply styles if we have a valid pseudo-class
  if (Object.keys(otherEventStyles).length > 0) {
    const pseudo = EVENT_TO_PSEUDO[eventName];
    if (pseudo) {
      classes.push(
        ...processStyles(otherEventStyles, 'pseudo', pseudo, getColor)
      );
    }
  }

  return classes;
}

export const extractUtilityClasses = (
  props: ElementProps,
  getColor: (color: string) => string,
  mediaQueries: Record<string, string>,
  devices: Record<string, string[]>
): string[] => {
  const classes: string[] = [];
  const computedStyles: Record<string, any> = {};

  // Handle widthHeight (shorthand for both width and height)
  if (
    props.widthHeight ||
    (props.height !== undefined &&
      props.width !== undefined &&
      props.height === props.width)
  ) {
    const widthHeightValue = props.widthHeight || props.width;
    const formattedValue =
      typeof widthHeightValue === 'number'
        ? `${widthHeightValue}px`
        : widthHeightValue;
    computedStyles.width = formattedValue;
    computedStyles.height = formattedValue;
  }

  // Handle padding and margin shorthands
  const shorthandProps = {
    paddingHorizontal: ['paddingLeft', 'paddingRight'],
    paddingVertical: ['paddingTop', 'paddingBottom'],
    marginHorizontal: ['marginLeft', 'marginRight'],
    marginVertical: ['marginTop', 'marginBottom'],
  };

  for (const [shorthand, properties] of Object.entries(shorthandProps)) {
    const value = (props as any)[shorthand];
    if (value !== undefined) {
      const formattedValue = typeof value === 'number' ? `${value}px` : value;
      properties.forEach((prop) => {
        computedStyles[prop] = formattedValue;
      });
    }
  }

  // Handle shadows
  if (props.shadow !== undefined) {
    let shadowValue: number;

    if (
      typeof props.shadow === 'number' &&
      Shadows[props.shadow] !== undefined
    ) {
      shadowValue = props.shadow;
    } else if (typeof props.shadow === 'boolean') {
      shadowValue = props.shadow ? 2 : 0;
    } else {
      shadowValue = 2;
    }

    if (Shadows[shadowValue]) {
      const { shadowColor, shadowOpacity, shadowOffset, shadowRadius } =
        Shadows[shadowValue];
      const rgb = Color.hex.rgb(shadowColor);
      const rgbaColor = `rgba(${rgb.join(',')}, ${shadowOpacity})`;
      computedStyles.boxShadow = `${shadowOffset.height}px ${shadowOffset.width}px ${shadowRadius}px ${rgbaColor}`;
    }
  }

  // Handle animations
  if (props.animate) {
    const animations = Array.isArray(props.animate)
      ? props.animate
      : [props.animate];
    Object.assign(computedStyles, AnimationUtils.processAnimations(animations));
  }

  // Process base styles
  classes.push(...processStyles(computedStyles, 'base', '', getColor));

  // Collect underscore-prefixed properties (_hover, _focus, etc.)
  const underscoreProps: Record<string, any> = {};
  Object.keys(props).forEach((property) => {
    if (property.startsWith('_') && property.length > 1) {
      const eventName = property.substring(1);
      underscoreProps[eventName] = (props as any)[property];
    }
  });

  // Process standard style props
  Object.keys(props).forEach((property) => {
    if (
      property !== 'style' &&
      property !== 'css' &&
      !property.startsWith('_') &&
      (isStyleProp(property) || ['on', 'media'].includes(property))
    ) {
      const value = (props as any)[property];

      if (typeof value === 'object' && value !== null) {
        if (property === 'on') {
          // Process event-based styles
          Object.keys(value).forEach((event) => {
            classes.push(...processEventStyles(event, value[event], getColor));
          });
        } else if (property === 'media') {
          // Process media query styles
          Object.keys(value).forEach((screenOrDevice) => {
            classes.push(
              ...processStyles(
                value[screenOrDevice],
                'media',
                screenOrDevice,
                getColor,
                mediaQueries,
                devices
              )
            );
          });
        }
      } else if (value !== undefined && value !== '') {
        // Direct style property
        classes.push(
          ...utilityClassManager.getClassNames(
            property,
            value,
            'base',
            '',
            getColor,
            []
          )
        );
      }
    }
  });

  // Handle raw CSS
  if (props.css) {
    if (typeof props.css === 'object') {
      // Object-style CSS gets processed as regular styles
      Object.assign(computedStyles, props.css);
      classes.push(...processStyles(props.css, 'base', '', getColor));
    } else if (typeof props.css === 'string') {
      // String-style CSS gets its own class
      const uniqueClassName = ValueUtils.generateUniqueClassName(props.css);
      utilityClassManager.injectRule(`.${uniqueClassName} { ${props.css} }`);
      classes.push(uniqueClassName);
    }
  }

  // Process underscore-prefixed event properties
  if (Object.keys(underscoreProps).length > 0) {
    Object.keys(underscoreProps).forEach((event) => {
      classes.push(
        ...processEventStyles(event, underscoreProps[event], getColor)
      );
    });
  }

  return classes;
};



================================================================
End of Codebase
================================================================
